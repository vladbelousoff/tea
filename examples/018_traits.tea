// Traits: interfaces that define shared behavior across different types

// Define traits (interfaces)
trait Display {
    fn to_string() -> string;
    fn show();
}

trait Drawable {
    fn draw();
    fn area() -> f32;
}

trait Comparable {
    fn equals(other: Self) -> f32;  // Note: Self might not be supported, using specific types
    fn less_than(other: Self) -> f32;
}

// Define structs
struct Point {
    x: f32;
    y: f32;
}

struct Rectangle {
    width: f32;
    height: f32;
}

struct Circle {
    radius: f32;
}

// Implement Display trait for Point
impl Display for Point {
    fn to_string() -> string {
        return 'Point';  // Simplified - string interpolation might not be available
    }
    
    fn show() {
        // In a real implementation, this would print the point
        print('Showing point');
    }
}

// Implement Drawable trait for Point
impl Drawable for Point {
    fn draw() {
        print('Drawing point at coordinates');
    }
    
    fn area() -> f32 {
        return 0.0;  // Points have no area
    }
}

// Implement Display trait for Rectangle
impl Display for Rectangle {
    fn to_string() -> string {
        return 'Rectangle';
    }
    
    fn show() {
        print('Showing rectangle');
    }
}

// Implement Drawable trait for Rectangle
impl Drawable for Rectangle {
    fn draw() {
        print('Drawing rectangle');
    }
    
    fn area() -> f32 {
        return self.width * self.height;
    }
}

// Implement Display trait for Circle
impl Display for Circle {
    fn to_string() -> string {
        return 'Circle';
    }
    
    fn show() {
        print('Showing circle');
    }
}

// Implement Drawable trait for Circle
impl Drawable for Circle {
    fn draw() {
        print('Drawing circle');
    }
    
    fn area() -> f32 {
        return 3.14159 * self.radius * self.radius;
    }
}

// Implement Comparable trait for Point
impl Comparable for Point {
    fn equals(other: Point) -> f32 {
        if self.x == other.x && self.y == other.y {
            return 1.0;  // true
        } else {
            return 0.0;  // false
        }
    }
    
    fn less_than(other: Point) -> f32 {
        let self_distance = self.x * self.x + self.y * self.y;
        let other_distance = other.x * other.x + other.y * other.y;
        
        if self_distance < other_distance {
            return 1.0;  // true
        } else {
            return 0.0;  // false
        }
    }
}

// Using traits - calling trait methods on struct instances
let point = new Point { x: 1.0, y: 2.0 };
let rect = new Rectangle { width: 5.0, height: 3.0 };
let circle = new Circle { radius: 2.5 };

// Call Display trait methods
point.show();              // Calls Display::show for Point
rect.show();               // Calls Display::show for Rectangle
circle.show();             // Calls Display::show for Circle

let point_str = point.to_string();    // Returns 'Point'
let rect_str = rect.to_string();      // Returns 'Rectangle'

// Call Drawable trait methods
point.draw();              // Calls Drawable::draw for Point
rect.draw();               // Calls Drawable::draw for Rectangle
circle.draw();             // Calls Drawable::draw for Circle

let point_area = point.area();        // Returns 0.0
let rect_area = rect.area();          // Returns 15.0
let circle_area = circle.area();      // Returns ~19.63

// Call Comparable trait methods
let point2 = new Point { x: 3.0, y: 4.0 };
let are_equal = point.equals(point2); // Returns 0.0 (false)
let is_less = point.less_than(point2); // Returns 1.0 (true, closer to origin)

// Using trait methods in expressions and conditions
let total_area = rect.area() + circle.area();

if point.equals(point2) > 0.0 {
    point.show();
} else {
    point2.show();
}

// Traits allow different types to share common interfaces
// This enables polymorphic behavior where different types
// can be treated uniformly through their shared trait methods